package main 

import (
	"math"
	"math/rand"
	"time"

	"github.com/tfriedel6/canvas"
	"github.com/tfriedel6/canvas/sdlcanvas"
	"github.com/veandco/go-sdl2/sdl"
)

type PatternConfig struct {
	Angle    float64
	Speed    float64
	TileSize float64
	Width    float64
	Color    string
	X        float64
	Y        float64
}

type Mode struct {
	F PatternConfig
	B PatternConfig
}

var (
	currentModeKey string
	currentMode    Mode

	baseConfigF PatternConfig
	baseConfigB PatternConfig
	modes       map[string]Mode

	shakeCounter   int
	glitchCounter  int
	glitchState    bool
	glitchDuration int
)

func init() {
	rand.Seed(time.Now().UnixNano())

	baseConfigF = PatternConfig{
		Angle:    225,
		Speed:    0.3,
		TileSize: 20,
		Width:    0.5,
		Color:    "#490049",
		X:        60,
		Y:        60,
	}

	baseConfigB = PatternConfig{
		Angle:    45,
		Speed:    0.3,
		TileSize: 20,
		Width:    0.5,
		Color:    "#240024",
		X:        0,
		Y:        0,
	}

	modes = make(map[string]Mode)
	modes["NORMAL"] = Mode{F: baseConfigF, B: baseConfigB}
	modes["HYPERDRIVE"] = Mode{F: baseConfigF, B: baseConfigB}
	modes["REDSHAKE"] = Mode{F: baseConfigF, B: baseConfigB}
	modes["GLITCHMATRIX"] = Mode{F: baseConfigF, B: baseConfigB}
}

func setMode(modeKey string) {
	currentModeKey = modeKey
	currentMode = modes[modeKey]
}

func mmain() {
	wnd, cv, err := sdlcanvas.CreateWindow(1024, 768, "sugma")
	if err != nil {
		panic(err)
	}
	defer wnd.Destroy()
  currentMode:="NORMAL"
	setMode("NORMAL")
  cv.SetFillStyle("#000")

	running := true
	for running {
		evs := sdl.PollEvent()
			switch e := evs.(type) {
			case *sdl.QuitEvent:
			  	running = false
      }
		

		width, height := cv.Size()

		// Clear canvas
		cv.FillRect(0, 0, float64(width), float64(height))

		// Animate current mode
		switch currentModeKey {
		case "NORMAL":
			animateNormal(cv, width, height)
		case "HYPERDRIVE":
			animateHyperdrive(cv, width, height)
		case "REDSHAKE":
			animateRedShake(cv, width, height)
		case "GLITCHMATRIX":
			animateGlitchMatrix(cv, width, height)
		}

	}
}

func animateNormal(cv *canvas.Canvas, width, height int) {
	updatePatternPosition(&currentMode.B)
	drawPattern(cv, &currentMode.B, width, height)
	updatePatternPosition(&currentMode.F)
	drawPattern(cv, &currentMode.F, width, height)
}

func animateHyperdrive(cv *canvas.Canvas, width, height int) {
	currentMode.F.Speed = 6
	currentMode.B.Speed = 6

	lightBlue := []string{"#42C2FF", "#85F4FF", "#B8FFF9"}
	darkBlue := []string{"#0B2447", "#19376D", "#576CBC"}

	currWidth := rand.Float64()*(3-0.5) + 0.5
	colour := rand.Intn(3)

	currentMode.B.Color = darkBlue[colour]
	currentMode.B.Width = currWidth

	currentMode.F.Color = lightBlue[colour]
	currentMode.F.Width = currWidth

	updatePatternPosition(&currentMode.B)
	drawPattern(cv, &currentMode.B, width, height)
	updatePatternPosition(&currentMode.F)
	drawPattern(cv, &currentMode.F, width, height)
}

func animateRedShake(cv *canvas.Canvas, width, height int) {
	if shakeCounter%120 == 0 {
		currentMode.F.Angle, currentMode.B.Angle = currentMode.B.Angle, currentMode.F.Angle
		currentMode.F.Color = "#DC0000"
		currentMode.B.Color = "#850000"
	}

	currentMode.F.X += rand.Float64()*10 - 5
	currentMode.F.Y += rand.Float64()*10 - 5
	currentMode.B.X += rand.Float64()*10 - 5
	currentMode.B.Y += rand.Float64()*10 - 5

	updatePatternPosition(&currentMode.F)
	drawPattern(cv, &currentMode.F, width, height)
	updatePatternPosition(&currentMode.B)
	drawPattern(cv, &currentMode.B, width, height)

	shakeCounter++
}

func animateGlitchMatrix(cv *canvas.Canvas, width, height int) {
	if glitchCounter >= glitchDuration {
		glitchState = !glitchState
		glitchCounter = 0

		lightGreen := []string{"#38b000", "#70e000", "#9ef01a"}
		darkGreen := []string{"#538d22", "#538d22", "#aad576"}

		colour := rand.Intn(3)
		if glitchState {
			glitchDuration = rand.Intn(40)
			currentMode.F = baseConfigB
			currentMode.B = baseConfigF
			currentMode.F.Color = lightGreen[colour]
			currentMode.B.Color = darkGreen[colour]
			currentMode.F.Speed = 3
			currentMode.B.Speed = 3
		} else {
			glitchDuration = rand.Intn(25)
			currentMode.F = baseConfigF
			currentMode.B = baseConfigB
			currentMode.F.Speed = 0.3
			currentMode.B.Speed = 0.3
		}
	}

	if glitchState {
		if rand.Float64() >= 0.47 {
			updatePatternPosition(&currentMode.F)
			drawPattern(cv, &currentMode.F, width, height)
			updatePatternPosition(&currentMode.B)
			drawPattern(cv, &currentMode.B, width, height)
		} else {
			drawPattern(cv, &currentMode.F, width, height)
			drawPattern(cv, &currentMode.B, width, height)
		}
	} else {
		updatePatternPosition(&currentMode.F)
		drawPattern(cv, &currentMode.F, width, height)
		updatePatternPosition(&currentMode.B)
		drawPattern(cv, &currentMode.B, width, height)
	}

	glitchCounter++
}

func drawPattern(cv *canvas.Canvas, pattern *PatternConfig, width, height int) {
	cv.SetStrokeStyle(pattern.Color)
	cv.SetLineWidth(pattern.Width)

	tileSize := pattern.TileSize
	w := float64(width)
	h := float64(height)

	for i := -tileSize; i < w; {
		for j := -tileSize; j < h; {
			cv.StrokeRect(pattern.X+i, pattern.Y+j, tileSize, tileSize)
			j += tileSize
		}
		i += tileSize
	}
}

func updatePatternPosition(pattern *PatternConfig) {
	radians := degreesToRadians(pattern.Angle)
	offsetX := math.Cos(radians) * pattern.Speed
	offsetY := math.Sin(radians) * pattern.Speed

	pattern.X += offsetX
	pattern.Y += offsetY

	tileSize := pattern.TileSize
	if pattern.X >= tileSize || pattern.X <= -tileSize ||
		pattern.Y >= tileSize || pattern.Y <= -tileSize {
		pattern.X = 0
		pattern.Y = 0
	}
}

func degreesToRadians(degrees float64) float64 {
	return degrees * math.Pi / 180
}
